/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
 *
 * The information contained herein is property of Nordic Semiconductor ASA.
 * Terms and conditions of usage are described in detail in NORDIC
 * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
 *
 * Licensees are granted free, non-transferable use of the information. NO
 * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
 * the file.
 *
 * $LastChangedRevision$
 */
 
/**
 * Initial step for porting to a new mcu template
 */

/** @defgroup initial_step_for_port initial_step_for_port
@{
@ingroup projects
@brief Empty project that can be used as a template for porting the nRF8001 SDK to a new mcu.

@details
This project is a firmware template for new projects. 
The project will run correctly in its current state, it puts the nRF8001 in test mode and
then sends echo commands and, then it waits for echo events for the echo commands. 
Use this project to verify your port of the Interrupt based SPI/ACI driver and to test the
integrity of the SPI.
    
 */
#include <SPI.h>
#include <avr/pgmspace.h>
#include <ble_system.h>
#include <aci.h>
#include <aci_cmds.h>
#include <aci_evts.h>
#include <lib_aci.h>


//aci_struct that will contain 
// total initial credits
// current credit
// current state of the aci (setup/standby/active/sleep)
// open remote pipe pending
// close remote pipe pending
// Current pipe available bitmap
// Current pipe closed bitmap
// Current connection interval, slave latency and link supervision timeout
// Current State of the the GATT client (Service Discovery)
// Status of the bond (R) Peer address
static struct aci_state_t aci_state;
static hal_aci_evt_t aci_data;
static hal_aci_data_t aci_cmd;




void setup(void)
{ 
  Serial.begin(115200);
  Serial.println(F("Arduino setup"));
  
  /*
  Tell the ACI library, the MCU to nRF8001 pin connections.
  The Active pin is optional and can be marked UNUSED
  */	  	
  aci_state.aci_pins.board_name = REDBEARLAB_SHIELD_V1_1; //See board.h for details
  aci_state.aci_pins.reqn_pin   = 9;
  aci_state.aci_pins.rdyn_pin   = 8;
  aci_state.aci_pins.mosi_pin   = MOSI;
  aci_state.aci_pins.miso_pin   = MISO;
  aci_state.aci_pins.sck_pin    = SCK;

  aci_state.aci_pins.spi_clock_divider     = SPI_CLOCK_DIV8;
	  
  aci_state.aci_pins.reset_pin             = UNUSED;
  aci_state.aci_pins.active_pin            = UNUSED;
  aci_state.aci_pins.optional_chip_sel_pin = UNUSED;
	  
  aci_state.aci_pins.interface_is_interrupt	  = false;
  aci_state.aci_pins.interrupt_number	      = 1;  
  
  //This will reset the nRF8001. ACI Device Started Event is generated by the nRF8001 device
  //as soon as the reset is complete
  hal_aci_tl_init(&(aci_state.aci_pins));
}


bool aci_echo(void)
{
      //Send the ACI Echo Command
    aci_cmd.buffer[0] = 30;   //Length of ACI Command
    aci_cmd.buffer[1] = 0x02; //Command - Echo
    {
      uint8_t loop=0;
      for (loop=0; loop<29; loop++)
      {
        aci_cmd.buffer[2+loop]=loop; //Command parameter
      }
    }
    return hal_aci_tl_send(&aci_cmd);
}

void loop()
{
  // We enter the if statement only when there is a ACI event available to be processed
  if (lib_aci_event_get(&aci_state, &aci_data))
  {
    aci_evt_t * aci_evt;
    
    aci_evt = &aci_data.evt;    
    switch(aci_evt->evt_opcode)
    {
        /**
        As soon as you reset the nRF8001 you will get an ACI Device Started Event
        */
        case ACI_EVT_DEVICE_STARTED:
        {          
          aci_state.data_credit_available = aci_evt->params.device_started.credit_available;
          switch(aci_evt->params.device_started.device_mode)
          {
            case ACI_DEVICE_SETUP:
              /**
              Device is in the setup mode
              */
              Serial.println(F("Evt Device Started: Setup"));
              aci_cmd.buffer[0] = 2;    //Length of ACI command
              aci_cmd.buffer[1] = 0x01; //Command - Test
              aci_cmd.buffer[2] = ACI_TEST_MODE_DTM_UART; //Command parameter
              hal_aci_tl_send(&aci_cmd);
              break;
            
            case ACI_DEVICE_TEST:
              Serial.println(F("Evt Device Started: Test"));
              Serial.println(F("Sending 3 Echo commands"));
              aci_echo();
              aci_echo();
              aci_echo();
              break;
            
            case ACI_DEVICE_STANDBY:
              Serial.println(F("Evt Device Started: Standby"));
              break;
          }
        }
        break; //ACI Device Started Event
      case ACI_EVT_CMD_RSP:
        //If an ACI command response event comes with an error -> stop
        if (ACI_STATUS_SUCCESS != aci_evt->params.cmd_rsp.cmd_status)
        {
          //ACI ReadDynamicData and ACI WriteDynamicData will have status codes of
          //TRANSACTION_CONTINUE and TRANSACTION_COMPLETE
          //all other ACI commands will have status code of ACI_STATUS_SCUCCESS for a successful command
          Serial.print(F("ACI Command "));
          Serial.println(aci_evt->params.cmd_rsp.cmd_opcode, HEX);
          Serial.println(F("Evt Cmd respone: Error. Arduino is in an while(1); loop"));
          while (1);
        }
        break;
      case ACI_EVT_ECHO:
        {
          uint8_t loop=0;
          
          for(loop=0; loop < aci_evt->len-1; loop++)
          {
            if (aci_evt->params.echo.echo_data[loop] != loop)
            {
              Serial.println(F("ACI Echo failed. Check SPI transport."));
              break;
            }
          }
          if (loop == aci_evt->len-1)
          {
            Serial.println(F("ACI Echo Ok"));
          }
        }
        break;
    }
  }
  else
  {
    //Serial.println(F("No ACI Events available"));
    // No event in the ACI Event queue.
    // If no commands are in the command queue - Arduino can go to sleep
    // Wakeup from sleep from the RDYN line
  }
}

