/*Copyright (c) 2013, Nordic Semiconductor ASA
 *All rights reserved.
 *
 *Redistribution and use in source and binary forms, with or without modification,
 *are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice, this
 *  list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *
 *  Neither the name of Nordic Semiconductor ASA nor the names of its
 *  contributors may be used to endorse or promote products derived from
 *  this software without specific prior written permission.
 *
 *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 *ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 *ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
/**
 * Initial step for porting to a new mcu template
 */

/** @defgroup initial_step_for_port initial_step_for_port
@{
@ingroup projects
@brief Empty project that can be used as a template for porting the nRF8001 SDK to a new mcu.

@details
This project is a firmware template for new projects. 
The project will run correctly in its current state, it puts the nRF8001 in test mode and
then sends echo commands and, then it waits for echo events for the echo commands. 
Use this project to verify your port of the Interrupt based SPI/ACI driver and to test the
integrity of the SPI.
    
 */
#include <SPI.h>
#include <avr/pgmspace.h>
#include <ble_system.h>
#include <aci.h>
#include <aci_cmds.h>
#include <aci_evts.h>
#include <lib_aci.h>


//aci_struct that will contain 
// total initial credits
// current credit
// current state of the aci (setup/standby/active/sleep)
// open remote pipe pending
// close remote pipe pending
// Current pipe available bitmap
// Current pipe closed bitmap
// Current connection interval, slave latency and link supervision timeout
// Current State of the the GATT client (Service Discovery)
// Status of the bond (R) Peer address
static struct aci_state_t aci_state;
static hal_aci_evt_t aci_data;
static hal_aci_data_t aci_cmd;




void setup(void)
{ 
  Serial.begin(115200);
  Serial.println(F("Arduino setup"));
  
  /*
  Tell the ACI library, the MCU to nRF8001 pin connections.
  The Active pin is optional and can be marked UNUSED
  */	  	
  aci_state.aci_pins.board_name = REDBEARLAB_SHIELD_V1_1; //See board.h for details
  aci_state.aci_pins.reqn_pin   = 9;
  aci_state.aci_pins.rdyn_pin   = 8;
  aci_state.aci_pins.mosi_pin   = MOSI;
  aci_state.aci_pins.miso_pin   = MISO;
  aci_state.aci_pins.sck_pin    = SCK;

  aci_state.aci_pins.spi_clock_divider     = SPI_CLOCK_DIV8;
	  
  aci_state.aci_pins.reset_pin             = UNUSED;
  aci_state.aci_pins.active_pin            = UNUSED;
  aci_state.aci_pins.optional_chip_sel_pin = UNUSED;
	  
  aci_state.aci_pins.interface_is_interrupt	  = false;
  aci_state.aci_pins.interrupt_number	      = 1;  
  
  //This will reset the nRF8001. ACI Device Started Event is generated by the nRF8001 device
  //as soon as the reset is complete
  hal_aci_tl_init(&(aci_state.aci_pins));
}


bool aci_echo(void)
{
      //Send the ACI Echo Command
    aci_cmd.buffer[0] = 30;   //Length of ACI Command
    aci_cmd.buffer[1] = 0x02; //Command - Echo
    {
      uint8_t loop=0;
      for (loop=0; loop<29; loop++)
      {
        aci_cmd.buffer[2+loop]=loop; //Command parameter
      }
    }
    return hal_aci_tl_send(&aci_cmd);
}

void loop()
{
  // We enter the if statement only when there is a ACI event available to be processed
  if (lib_aci_event_get(&aci_state, &aci_data))
  {
    aci_evt_t * aci_evt;
    
    aci_evt = &aci_data.evt;    
    switch(aci_evt->evt_opcode)
    {
        /**
        As soon as you reset the nRF8001 you will get an ACI Device Started Event
        */
        case ACI_EVT_DEVICE_STARTED:
        {          
          aci_state.data_credit_available = aci_evt->params.device_started.credit_available;
          switch(aci_evt->params.device_started.device_mode)
          {
            case ACI_DEVICE_SETUP:
              /**
              Device is in the setup mode
              */
              Serial.println(F("Evt Device Started: Setup"));
              aci_cmd.buffer[0] = 2;    //Length of ACI command
              aci_cmd.buffer[1] = 0x01; //Command - Test
              aci_cmd.buffer[2] = ACI_TEST_MODE_DTM_UART; //Command parameter
              hal_aci_tl_send(&aci_cmd);
              break;
            
            case ACI_DEVICE_TEST:
              Serial.println(F("Evt Device Started: Test"));
              Serial.println(F("Sending 3 Echo commands"));
              aci_echo();
              aci_echo();
              aci_echo();
              break;
            
            case ACI_DEVICE_STANDBY:
              Serial.println(F("Evt Device Started: Standby"));
              break;
          }
        }
        break; //ACI Device Started Event
      case ACI_EVT_CMD_RSP:
        //If an ACI command response event comes with an error -> stop
        if (ACI_STATUS_SUCCESS != aci_evt->params.cmd_rsp.cmd_status)
        {
          //ACI ReadDynamicData and ACI WriteDynamicData will have status codes of
          //TRANSACTION_CONTINUE and TRANSACTION_COMPLETE
          //all other ACI commands will have status code of ACI_STATUS_SCUCCESS for a successful command
          Serial.print(F("ACI Command "));
          Serial.println(aci_evt->params.cmd_rsp.cmd_opcode, HEX);
          Serial.println(F("Evt Cmd respone: Error. Arduino is in an while(1); loop"));
          while (1);
        }
        break;
      case ACI_EVT_ECHO:
        {
          uint8_t loop=0;
          
          for(loop=0; loop < aci_evt->len-1; loop++)
          {
            if (aci_evt->params.echo.echo_data[loop] != loop)
            {
              Serial.println(F("ACI Echo failed. Check SPI transport."));
              break;
            }
          }
          if (loop == aci_evt->len-1)
          {
            Serial.println(F("ACI Echo Ok"));
          }
        }
        break;
    }
  }
  else
  {
    //Serial.println(F("No ACI Events available"));
    // No event in the ACI Event queue.
    // If no commands are in the command queue - Arduino can go to sleep
    // Wakeup from sleep from the RDYN line
  }
}

